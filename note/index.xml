<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes on JIMBRAY</title>
    <link>https://jimbray.xyz/note/</link>
    <description>Recent content in Notes on JIMBRAY</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Mon, 13 Aug 2018 20:20:20 +0800</lastBuildDate>
    
	<atom:link href="https://jimbray.xyz/note/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>隐私政策</title>
      <link>https://jimbray.xyz/note/content/app_privicy_policy/</link>
      <pubDate>Mon, 13 Aug 2018 20:20:20 +0800</pubDate>
      
      <guid>https://jimbray.xyz/note/content/app_privicy_policy/</guid>
      <description> 本应用尊重并保护所有使用服务用户的个人隐私权。 为了给您提供更准确、更有个性化的服务，本应用会按照本隐私权政策的规定使用和披露您的个人信息。但本应用将以高度的勤勉、审慎义务对待这些信息。 除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三方提供。 本应用会不时更新本隐私权政策。 您在同意本应用服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本应用服务使用协议不可分割的一部分。 1. 适用范围 (a) 在您注册本应用帐号时，您根据本应用要求提供的个人注册信息；(b) 在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器和计算机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据；&amp;copy; 本应用通过合法途径从商业伙伴处取得的用户个人数据。您了解并同意，以下信息不适用本隐私权政策：(a) 您在使用本应用平台提供的搜索服务时输入的关键字信息；(b) 本应用收集到的您在本应用发布的有关信息数据，包括但不限于参与活动、成交信息及评价详情；&amp;copy; 违反法律规定或违反本应用规则行为及本应用已对您采取的措施。 2. 信息使用 (a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。(b) 本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。&amp;copy; 为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。 3. 信息披露 在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息：(a) 经您事先同意，向第三方披露；(b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息；&amp;copy; 根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；(d) 如您出现违反中国有关法律、法规或者本应用服务协议或相关规则的情况，需要向第三方披露；(e) 如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷；(f) 在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。(g) 其它本应用根据法律、法规或者网站政策认为合适的披露。 4. 信息存储和交换 本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。 5. Cookie的使用 (a) 在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。(b) 您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。&amp;copy; 通过本应用所设cookies所取得的有关信息，将适用本政策。 6. 信息安全 (a) 本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。(b) 在使用本应用网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对 7.本隐私政策的更改 (a)如果决定更改隐私政策，我们会在本政策中、本公司网站中以及我们认为适当的位置发布这些更改，以便您了解我们如何收集、使用您的个人信息，哪些人可以访问这些信息，以及在什么情况下我们会透露这些信息。(b)本公司保留随时修改本政策的权利，因此请经常查看。如对本政策作出重大更改，本公司会通过网站通知的形式告知。 方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，尤其是本应用用户名及密码发生泄露，请您立即联络本应用客服，以便本应用采取相应措施。] </description>
    </item>
    
    <item>
      <title>对象锁与类锁</title>
      <link>https://jimbray.xyz/note/content/lock-object-%E5%89%AF%E6%9C%AC/</link>
      <pubDate>Wed, 06 Jun 2018 16:16:16 +0000</pubDate>
      
      <guid>https://jimbray.xyz/note/content/lock-object-%E5%89%AF%E6%9C%AC/</guid>
      <description>public class Person { private String name; private static final String TAG = Person.class.getSimpleName(); public Person(String name) { this.name = name; } // Synchronized修饰一个方法 public synchronized void say(){ for(int i = 0; i &amp;lt; 10; i++){ try { Log.d(TAG, name + &amp;quot; say -&amp;gt; &amp;quot; + i) Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } // Synchronized修饰一个代码块 // 如果像这样代码块是函数内的全部代码，那同步效果与上面修饰方法是一样的 public void say(){ synchronized(this) { for(int i = 0; i &amp;lt; 10; i++){ try { Log.</description>
    </item>
    
    <item>
      <title>对象锁与类锁</title>
      <link>https://jimbray.xyz/note/content/lock-object/</link>
      <pubDate>Wed, 06 Jun 2018 16:16:16 +0000</pubDate>
      
      <guid>https://jimbray.xyz/note/content/lock-object/</guid>
      <description>public class Person { private String name; private static final String TAG = Person.class.getSimpleName(); public Person(String name) { this.name = name; } // Synchronized修饰一个方法 public synchronized void say(){ for(int i = 0; i &amp;lt; 10; i++){ try { Log.d(TAG, name + &amp;quot; say -&amp;gt; &amp;quot; + i) Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } // Synchronized修饰一个代码块 // 如果像这样代码块是函数内的全部代码，那同步效果与上面修饰方法是一样的 public void say(){ synchronized(this) { for(int i = 0; i &amp;lt; 10; i++){ try { Log.</description>
    </item>
    
    <item>
      <title>设计模式学习笔记</title>
      <link>https://jimbray.xyz/note/content/design-patterns/</link>
      <pubDate>Wed, 06 Jun 2018 16:16:16 +0000</pubDate>
      
      <guid>https://jimbray.xyz/note/content/design-patterns/</guid>
      <description>设计模式的三个分类
 创建型模式 结构型模式 行为型模式  创建型模式 对象实例化的模式，创建型模式用于结构对象的实例化过程
 单例模式：某个类只能有一个实例，提供一个全局的访问点 工厂模式  简单工厂：一个工厂类根据传入的产量决定创建出哪一种产品类的实例 工厂方法：定义一个创建对象的接口，让子类实例化哪个类 抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类  建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造 原形模式：通过复制现有的实例来创建新的实例  单例模式 单例模式的写法有很多种，一个一个地看一下
 饿汉式  public class Singleton { private Singleton singleton = new Singleton(); private Singleton() {} public static Singleton getInstance() { return singleton; } }  这段代码的好处是编写简单，但是无法做到延迟创建对象。但是我们很多时候都希望对象可以尽可能地延迟加载，从而减少负载，所以还能改进。
 单线程写法  public class Singleton { private static Singleton singleton = null; private Singleton() {} public static Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; } }  这种写法也是很简单的， 由私有构造方法和一个公有静态工厂方法构成，在工厂方法中对对象进行判空处理，为空时再进行实例对象的操作。这种方式可以延迟加载，但是有一个弱点：线程不安全。</description>
    </item>
    
    <item>
      <title>Ubuntu16.04安装nginx&#43;php7环境记录</title>
      <link>https://jimbray.xyz/note/content/ubuntu16_install_nginx_and_php7/</link>
      <pubDate>Thu, 19 Apr 2018 15:10:46 +0800</pubDate>
      
      <guid>https://jimbray.xyz/note/content/ubuntu16_install_nginx_and_php7/</guid>
      <description>第一步 更新源
apt-get update  第二步：安装nginx 直接安装
sudo apt-get install nginx  打开nginx 服务
sudo service nginx start  测试是否成功
在浏览器输入ip地址，出现以下界面
即表示安装成功。
第三步：安装php7 sudo apt-get install php7.0-fpm  打开nginx 配置文件
sudo vi /etc/nginx/sites-available/default  未免修改错误，可以先进行 defaule配置文件的备份
sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/default.bak  在 defult 文件中找到以下 代码段
# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # # location ~ \.php$ { # include snippets/fastcgi-php.conf; # # # With php7.</description>
    </item>
    
    <item>
      <title>理论上一个APP可以使用多大的内存</title>
      <link>https://jimbray.xyz/note/content/how_much_mem_per_app_alloc/</link>
      <pubDate>Tue, 10 Apr 2018 09:30:27 +0800</pubDate>
      
      <guid>https://jimbray.xyz/note/content/how_much_mem_per_app_alloc/</guid>
      <description>准确的说法是 Google 原生OS 默认值是 16M，但是各个厂家的定制OS会对这个值进行修改。所以理论上是不固定的，由厂家决定，我也没有测试过。</description>
    </item>
    
    <item>
      <title>什么是弱引用</title>
      <link>https://jimbray.xyz/note/content/what_is_weakreference/</link>
      <pubDate>Mon, 09 Apr 2018 11:03:18 +0800</pubDate>
      
      <guid>https://jimbray.xyz/note/content/what_is_weakreference/</guid>
      <description>弱引用（WeakReference）与强引用（日常提到的引用）相对，弱引用的特点是，在GC回收的时候会忽略掉弱引用，即就算有弱引用指向某对象，但只有该对象没有被强引用指向，该对象就会被GC回收掉。</description>
    </item>
    
    <item>
      <title>为什么Handler容易引起内存泄露</title>
      <link>https://jimbray.xyz/note/content/why_handler_make_leak_mem/</link>
      <pubDate>Mon, 09 Apr 2018 10:30:48 +0800</pubDate>
      
      <guid>https://jimbray.xyz/note/content/why_handler_make_leak_mem/</guid>
      <description>首先还是先了解一下什么叫内存泄露
####内存泄漏
 Java 使用有向图机制，通过GC自动检查内存中的对象（什么时候检查交给虚拟机决定）,如果GC发现一个或一组对象为不可达状态，则将该对象从内存中回收。
也就是说，一个对象不被任何引用所指向，则该对象会被在GC发现的时候被回收；
还有一种情况是，如果一组对象中只包含互相的应用，而没有来自他们外部的应用，仍然属于不可达的范围，同样会被GC回收。
 可以总结为两个词：
 不可达 无根  就会被GC回收。
内存泄漏会发生什么？ Android中经常出现的一种现象：内存占用越来越大，App越用越卡，只有在强制关闭程序后才会有好转的迹象，这个就属于内存泄漏。而导致内存越来越大的原因有很多，其中最主要的原因之一，就是内存泄漏。
Handler 是怎么把内存泄漏的？ Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { iv_test.setImageBitmap(mBitmap); } }  这是一段很简单的 handler 。但使用内部类（包括匿名类）来创建Handler 的时候，Handler对象会*隐式*地持有一个外部类对象的引用（一般是一个 Activity）。
而Handler的主要使用场景是处理一个耗时的任务，等待任务处理完成之后，通过Handler 的消息机制通知到 Activity，然后完成更新界面的工作。
但是，移动端的交互方式决定了何时关闭Activity是由用户决定的，如果在耗时任务完成之前，Activity就被关闭了。正常情况下，由于用户关闭了Activity，所以Activity申请的相关资源内存，应该要被释放掉。
但是，之前的 【学习笔记】Looper 与 Handler 的关系 学习到了一点，Handler在发送消息的时候，会把Message 排队到 一个 消息队列里面 (MessageQueue)，等到任务完成后，再从消息队列里面取出来，通知handler，这里的关系是 引用持有关系可以表现为 MessageQueue -&amp;gt; Message -&amp;gt; Handler -&amp;gt; Activity，但任务没有完成的情况下，Activity理应被回收的业务逻辑下，由于Activity的引用被持有，导致GC不会去进行回收操作，这个就形成了内存泄漏。
内存泄漏有什么危害 导致虚拟机占用内存过高，导致OOM，程序崩溃。对于Android来说，目前这种Android手机越用越卡的第一印象很大程度上与应用的质量有很大的关系，应用没有很好地解决性能问题（内存泄漏只是其中一种情况）。用户打开一个Activity，关闭的时候并没有把之前向系统申请的内存回收掉，反复操作几次之后，就会出现内存超过系统限制的问题而被强制关闭，用户体验就不好了。
Handler导致内存泄漏的解决办法  通过程序逻辑进行保护   在Activity被关闭的时候，进行耗时任务的停止工作，任务被停止了，Activity也就没有被引用了。自然也就回收了。 在Activity被关闭的时候，在消息队列里面把Message消息（包含 Handler引用）remove掉，使用 handler.</description>
    </item>
    
    <item>
      <title>Linux 新增sudo用户</title>
      <link>https://jimbray.xyz/note/content/linux_adduser/</link>
      <pubDate>Tue, 03 Apr 2018 14:40:25 +0800</pubDate>
      
      <guid>https://jimbray.xyz/note/content/linux_adduser/</guid>
      <description>新增用户  使用root 用户登录
adduser jimbray  添加用户，然后根据提示输入密码
 加入 sudo 权限  修改 /etc/sudoers 文件权限
chmod 755 /etc/sudoers   修改 sudoers 文件  复制一行
root ALL=(ALL:ALL) ALL  最终结果为
root ALL=(ALL:ALL) ALL jimbray ALL=(ALL:ALL) ALL  完成。可以日常使用 jimbray 了。</description>
    </item>
    
    <item>
      <title>php7 如何重启 php-fpm</title>
      <link>https://jimbray.xyz/note/content/how-to-restart-php7-fpm/</link>
      <pubDate>Thu, 29 Mar 2018 16:16:51 +0800</pubDate>
      
      <guid>https://jimbray.xyz/note/content/how-to-restart-php7-fpm/</guid>
      <description>找到 php-fpm  ps aux | grep php   kill php-fpm  kill [对应的pid]   启动 php-fpm  /usr/local/php/sbin/php-fpm  ​</description>
    </item>
    
    <item>
      <title>Android 线程池中的核心线程</title>
      <link>https://jimbray.xyz/note/content/core_thread/</link>
      <pubDate>Fri, 02 Mar 2018 11:25:23 +0800</pubDate>
      
      <guid>https://jimbray.xyz/note/content/core_thread/</guid>
      <description> 核心线程即使在没有任务执行的时候也会存在，线程池一般设定一定数量的核心线程且一直存活，这样的话就可以一般情况下CPU创建或销毁线程带来的性能开销。如果线程池管理中设置了allowCoreThreadTimeout 时，核心线程就会有超时策略，这个时间由keepAliveTime来设定，即keepAliveTime时间内，如果核心线程无响应，则该核心线程就会被终止。如果allowCoreThreadTimeout没有设置，则核心线程没有超时时间。
 </description>
    </item>
    
    <item>
      <title>Android 线程池的优点</title>
      <link>https://jimbray.xyz/note/content/android_thread_advantage/</link>
      <pubDate>Fri, 02 Mar 2018 11:24:09 +0800</pubDate>
      
      <guid>https://jimbray.xyz/note/content/android_thread_advantage/</guid>
      <description> 复用线程池中的线程，避免频繁地创建和销毁线程带来的性能消耗 有效控制线程最大并发量，防止线程数量过多，导致抢占资源造成系统阻塞 可以有效地对线程进行管理  </description>
    </item>
    
    <item>
      <title>Android 线程池的分类</title>
      <link>https://jimbray.xyz/note/content/android_thread_type/</link>
      <pubDate>Fri, 02 Mar 2018 11:19:38 +0800</pubDate>
      
      <guid>https://jimbray.xyz/note/content/android_thread_type/</guid>
      <description>FixedThreadPool  它是一个线程数量固定的线程池，并且全是核心线程，没有超时机制且排队任务队列无限制。因为全是核心线程，所以响应比较快，而且不用担心线程会被回收。
 CachedThreadPool  它是一个数量无限多的线程池，所有的线程都是非核心线程，当有新任务来时，如果没有空闲的线程则直接创建新的线程不会去排队而直接执行，并且超时时间都是60s，所以当线程空闲一段时间时就会被系统回收，所以理论上该线程池不会有占用系统资源的无用线程。
 ScheduledThreadPool  它是一种像 FixedThreadPool 与 CachedThreadPool 两种线程池的合体，它有固体数量的核心线程，且有数量无限多的非核心线程，但非核心线程的超时时间是0秒，所以非核心线程一旦空闲会被马上回收。
 SingleThreadExecutor  它只有一个核心线程，确保所有的任务都要排队按顺序执行。它的意义在于，统一所有的外界任务到同一线程中，让使用者忽略线程同步问题。</description>
    </item>
    
    <item>
      <title>什么是ORM</title>
      <link>https://jimbray.xyz/note/content/orm/</link>
      <pubDate>Sun, 11 Feb 2018 21:13:14 +0800</pubDate>
      
      <guid>https://jimbray.xyz/note/content/orm/</guid>
      <description>ORM，全称 Object Relational Mapping，中文叫做 对象关系映射。
是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。
通俗一点理解或者举个例子就是：
将 数据库中的 数据抽象成 编程语言中的对象，将所有的数据持久化相关工作转换为变成语言的对象操作，用来屏蔽底层数据库的操作细节。
简单的 CRUD 甚至可以完全不懂 数据库操作也可以完成。</description>
    </item>
    
    <item>
      <title>进程与线程的区别</title>
      <link>https://jimbray.xyz/note/content/process_and_thread/</link>
      <pubDate>Sat, 20 Jan 2018 10:44:47 +0800</pubDate>
      
      <guid>https://jimbray.xyz/note/content/process_and_thread/</guid>
      <description>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.
2) 线程的划分尺度小于进程，使得多线程程序的并发性高。
3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</description>
    </item>
    
    <item>
      <title>记录</title>
      <link>https://jimbray.xyz/note/note/</link>
      <pubDate>Sat, 20 Jan 2018 10:39:42 +0800</pubDate>
      
      <guid>https://jimbray.xyz/note/note/</guid>
      <description>网站 V2EX | 知乎  | Github | 简书
学习笔记 进程与线程的区别 | ORM | Android 线程池的分类 | 使用线程池的优点 | 弱引用
| 理论上一个Android APP可以申请使用多大的内存 | 核心线程 | 为什么Handler容易引起内存泄露
php7 如何重启 php-fpm | ubuntu16.04安装nginx+php7环境记录
Linux新增sudo用户 | 对象锁与类锁 | 设计模式
工具 SVG转Vector Drawable | SVG在线编辑器 | 在线文件转换 | IP查询
JSON View Editor[jsonohyeah] | APKPure apk下载 | 在线工具合集 | Google系的在线图片压缩
Material Design配色工具 | Flutter Pakages</description>
    </item>
    
  </channel>
</rss>