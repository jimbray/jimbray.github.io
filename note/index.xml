<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes on JIMBRAY</title>
    <link>http://jimbray.xyz/note/</link>
    <description>Recent content in Notes on JIMBRAY</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Tue, 03 Apr 2018 14:40:25 +0800</lastBuildDate>
    
	<atom:link href="http://jimbray.xyz/note/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Linux 新增sudo用户</title>
      <link>http://jimbray.xyz/note/content/linux_adduser/</link>
      <pubDate>Tue, 03 Apr 2018 14:40:25 +0800</pubDate>
      
      <guid>http://jimbray.xyz/note/content/linux_adduser/</guid>
      <description>新增用户  使用root 用户登录
adduser jimbray  添加用户，然后根据提示输入密码
 加入 sudo 权限  修改 /etc/sudoers 文件权限
chmod 755 /etc/sudoers   修改 sudoers 文件  复制一行
root ALL=(ALL:ALL) ALL  最终结果为
root ALL=(ALL:ALL) ALL jimbray ALL=(ALL:ALL) ALL  完成。可以日常使用 jimbray 了。</description>
    </item>
    
    <item>
      <title>php7 如何重启 php-fpm</title>
      <link>http://jimbray.xyz/note/content/how-to-restart-php7-fpm/</link>
      <pubDate>Thu, 29 Mar 2018 16:16:51 +0800</pubDate>
      
      <guid>http://jimbray.xyz/note/content/how-to-restart-php7-fpm/</guid>
      <description>找到 php-fpm  ps aux | grep php   kill php-fpm  kill [对应的pid]   启动 php-fpm  /usr/local/php/sbin/php-fpm  ​</description>
    </item>
    
    <item>
      <title>Android 线程池中的核心线程</title>
      <link>http://jimbray.xyz/note/content/core_thread/</link>
      <pubDate>Fri, 02 Mar 2018 11:25:23 +0800</pubDate>
      
      <guid>http://jimbray.xyz/note/content/core_thread/</guid>
      <description> 核心线程即使在没有任务执行的时候也会存在，线程池一般设定一定数量的核心线程且一直存活，这样的话就可以一般情况下CPU创建或销毁线程带来的性能开销。如果线程池管理中设置了allowCoreThreadTimeout 时，核心线程就会有超时策略，这个时间由keepAliveTime来设定，即keepAliveTime时间内，如果核心线程无响应，则该核心线程就会被终止。如果allowCoreThreadTimeout没有设置，则核心线程没有超时时间。
 </description>
    </item>
    
    <item>
      <title>Android 线程池的优点</title>
      <link>http://jimbray.xyz/note/content/android_thread_advantage/</link>
      <pubDate>Fri, 02 Mar 2018 11:24:09 +0800</pubDate>
      
      <guid>http://jimbray.xyz/note/content/android_thread_advantage/</guid>
      <description> 复用线程池中的线程，避免频繁地创建和销毁线程带来的性能消耗 有效控制线程最大并发量，防止线程数量过多，导致抢占资源造成系统阻塞 可以有效地对线程进行管理  </description>
    </item>
    
    <item>
      <title>Android 线程池的分类</title>
      <link>http://jimbray.xyz/note/content/android_thread_type/</link>
      <pubDate>Fri, 02 Mar 2018 11:19:38 +0800</pubDate>
      
      <guid>http://jimbray.xyz/note/content/android_thread_type/</guid>
      <description>FixedThreadPool  它是一个线程数量固定的线程池，并且全是核心线程，没有超时机制且排队任务队列无限制。因为全是核心线程，所以响应比较快，而且不用担心线程会被回收。
 CachedThreadPool  它是一个数量无限多的线程池，所有的线程都是非核心线程，当有新任务来时，如果没有空闲的线程则直接创建新的线程不会去排队而直接执行，并且超时时间都是60s，所以当线程空闲一段时间时就会被系统回收，所以理论上该线程池不会有占用系统资源的无用线程。
 ScheduledThreadPool  它是一种像 FixedThreadPool 与 CachedThreadPool 两种线程池的合体，它有固体数量的核心线程，且有数量无限多的非核心线程，但非核心线程的超时时间是0秒，所以非核心线程一旦空闲会被马上回收。
 SingleThreadExecutor  它只有一个核心线程，确保所有的任务都要排队按顺序执行。它的意义在于，统一所有的外界任务到同一线程中，让使用者忽略线程同步问题。</description>
    </item>
    
    <item>
      <title>什么是ORM</title>
      <link>http://jimbray.xyz/note/content/orm/</link>
      <pubDate>Sun, 11 Feb 2018 21:13:14 +0800</pubDate>
      
      <guid>http://jimbray.xyz/note/content/orm/</guid>
      <description>ORM，全称 Object Relational Mapping，中文叫做 对象关系映射。
是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。
通俗一点理解或者举个例子就是：
将 数据库中的 数据抽象成 编程语言中的对象，将所有的数据持久化相关工作转换为变成语言的对象操作，用来屏蔽底层数据库的操作细节。
简单的 CRUD 甚至可以完全不懂 数据库操作也可以完成。</description>
    </item>
    
    <item>
      <title>进程与线程的区别</title>
      <link>http://jimbray.xyz/note/content/process_and_thread/</link>
      <pubDate>Sat, 20 Jan 2018 10:44:47 +0800</pubDate>
      
      <guid>http://jimbray.xyz/note/content/process_and_thread/</guid>
      <description>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.
2) 线程的划分尺度小于进程，使得多线程程序的并发性高。
3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</description>
    </item>
    
    <item>
      <title>记录</title>
      <link>http://jimbray.xyz/note/note/</link>
      <pubDate>Sat, 20 Jan 2018 10:39:42 +0800</pubDate>
      
      <guid>http://jimbray.xyz/note/note/</guid>
      <description>网址导航 V2EX
学习 进程与线程的区别 | ORM | Android 线程池的分类 | 使用线程池的优点
核心线程
php7 如何重启 php-fpm
Linux新增sudo用户
工具 SVG转Vector Drawable | SVG在线编辑器 | 在线文件转换 | IP查询
JSON View Editor[jsonohyeah] | APKPure apk下载</description>
    </item>
    
  </channel>
</rss>